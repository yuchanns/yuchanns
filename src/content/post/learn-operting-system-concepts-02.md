---
title: "操作系统概论-进程管理"
date: 2021-04-05T01:59:56+08:00
draft: false
---
## 进程描述
### 前置概念
* 程序的顺序执行
    * 一个程序执行结束前不能执行另一个程序
    * 顺序性、封闭性、可再现性
* 程序的并发执行
    * 同一时间间隔内运行多个程序
    * 宏观并行、微观串行
    * 间断性
    * 失去封闭性（不独占资源，比如并发抢票票数会减少）
    * 不可再现性（主要指PC保存的指令地址可能不一样）

程序是静态的，具有独立功能的一组指令的集合

### 进程的概念
进程是操作系统的核心。

进程是允许并发执行的程序在某个 **数据集合** 上的 **运行过程** 。

具有如下特征：
* 并发性：多个进程实体在同一时间间隔内同时运行
* 动态性：程序的一次执行过程
* 独立性：独立运行和资源调度的 **基本单位**
* 异步性：执行时断时续，无法预知
* 结构特征
    * 正文段（编写的代码）
    * 用户数据段（运行时数据）
    * 进程控制块（PCB）

### 进程控制块
操作系统中 **最重要的数据结构** 。

记录了操作系统需要的、用于 **描述进程及控制进程运行** 所需的全部信息：
* 进程标识符信息
* 处理机状态信息
    * 通用寄存器
    * 指令计数器
    * 程序状态字（PSW）
    * 用户栈指针
* 进程调度信息
    * 状态信息
    * 优先级
    * 调度所需的其他信息
* 进程控制信息

### 进程的状态
* 执行态：正在使用cpu执行指令
    * 分配时间用完变成 **就绪态**
    * 优先级降低变成 **就绪态**
    * 等待某一事件变成 **阻塞态**
* 阻塞态：等待或封锁
    * 等待的事件发生变成 **就绪态**
* 就绪态：
    * 等待调度策略调度变成 **执行态**

### 进程的组织
* 链接方式：把具有 **相同状态** 的 PCB 用其中的 **链接字** 连成一个队列
* 索引方式：根据进程的状态，分别建立 **索引表** ，每个表项指向一个 PCB，用队列指针寻找
* 进程队列：每一种类型的队列可以有多个，按照不同的优先级排序

## 进程的控制
进程的控制包括：创建、阻塞、唤醒和终止。

### 创建
条件：用户登录、作业调度、提供服务、应用请求

创建过程：
* 申请空白 PCB
* 为新进程分配资源
* 初始化 PCB
* 将新进程插入到就绪队列

执行可能：
* 父子并发执行
* 父等待子进程执行完毕

地址空间可能：
* 子进程共享父进程地址空间
* 子进程拥有独立地址空间

### 阻塞
条件：请求系统服务、启动某种操作、新数据尚未到达、无新工作可做

阻塞过程：
* 当前进程状态改为阻塞态
* 当前进程插入阻塞队列
* 进程调度程序从就绪队列中选择下一个进程为其分配 CPU（成为执行态）

### 唤醒
唤醒过程：
* 进程从阻塞队列移出
* 进程状态改为就绪态
* 进程插入就绪队列

### 终止
条件：正常执行完毕

终止过程：
* 从 PCB 读取进程状态
* 若进程正在执行，终止执行
* 释放资源
* 将终止进程的 PCB 移除

## 操作系统内核
内核执行操作系统与硬件关系密切、执行频率高的模块，常驻内存。

支撑功能：中断处理、时钟管理、原语操作

资源管理功能：进程管理、存储管理、设备管理

### 中断
**改变处理器执行指令顺序** 的一种事件。

出现中断时，计算机 **停止现在程序的运行** ，转向 **对这些中断事件的处理** ，处理结束后再 **返回到现行程序的间断处** 。

分类：
* 同步中断（内部中断或异常）
* 异步中断
    * 外部可屏蔽中断
    * 外部不可屏蔽中断

原因：
* 人为设置（代码设置）
* 程序性事故
* 硬件故障
* I/O 设备
* 外部事件

响应：
* 响应条件
* 响应时机

#### 中断的处理
单重中断处理：
* **开中断** 在 **中断返回** 之前
* 整个中断服务处理过程中不能再响应其他中断源的请求

![单重终端](/images/osc-interrupt-01.png)

多重中断处理：
* **开中断** 在 **保护现场** 之后
* 可以响应更高级别的中断源的请求，实现中断嵌套

### 时钟
计算机系统的脉搏， 计算机很多活动由 **定时测量** 驱动

分类：
* 实时时钟 RTC （ CMOS ）：供电硬件时钟
* OS 时钟：产生于定时/计数芯片，系统启动时由 RTC 初始化，每一个 cpu 周期加一

OS 时钟管理机制：

操作系统内核需要完成的两种定时测量是 **保存当前的日期和时间** 和 **维持定时器** 。

* 时钟硬件：**保存当前的日期和时间**，可编程定时计数器（ PIT, Programmable Interval Timer ）

![可编程定时计数器](/images/osc-pit-01.png)

每一次晶振，计数器加1，满了一个周期则保持寄存器加1，而计数器重置。

* 时钟驱动程序：**维持定时器**
    * 维护日期和时间
    * 递减当前进程在一个时间片内的剩余执行时间，防止运行超时
    * 对 CPU 的使用情况记账
    * 递减报警计数器

### 系统调用
一群 **预先定义好的模块** 。

提供 **一条管道** 让 **应用程序** 能由此到 **核心程序** 的服务。

系统调用是**系统程序** 与 **用户程序** 之间的 **接口** 。

与一般函数调用的区别：
* 一般函数以 **用户态** 执行
* 系统调用以 **系统态** 执行
* 执行过程不同，系统调用执行时，当前进程被中断
* 系统调用进行中断处理，多了系统开销

> 怎么理解用户态和系统态？
>
> 用户进程所在的地址空间称为用户空间。
>
> CPU 执行用户空间的代码时， 进程处于用户态执行。
>
> 含有一切系统核心代码的地址空间称为系统空间。
>
> CPU 执行系统核心代码时，进程处于系统态执行。

类型：
* 进程控制类
* 文件操纵类
* 设备管理类
* 通信类
* 信息维护类

## 进程同步
### 定义
进程并发地执行，共享系统的资源。共享过程由操作系统进行控制和管理。

**同步机制** 保证多任务共享系统资源的情况下，程序执行能得到正确的结果。

**信号量机制** 实现进程同步。

### 基本概念
多道程序环境下进程之间的关系可分为：
* 资源共享关系：进程同步保证各进程以 **互斥** 的方式访问 **临界资源**
* 相互合作关系：进程同步保证各进程 **协调** 执行

> 如何理解临界资源和临界区？
>
> 必须 **以互斥方式访问** 的共享资源称为 **临界资源**
>
> 进程中 **访问临界资源** 的 **代码片段** 称为 **临界区**

### 同步准则
> * 进入区：检查进程是否可以进入临界区并对临界区加锁
> * 临界区
> * 退出区：对临界区解锁

空闲让进、忙则等待、有限等待、让权等待

### 信号量机制
用 **信号量** 的取值来表示资源的使用状况，以此为基础实现进程同步。

分类：
* 整型信号量机制：
    * **表示共享资源状态** 且只能由特殊的 **原子操作** 改变的整型量
    * 定义一个 **整型变量** ，用该变量的值来 **标记资源的使用情况**
    * \> 0 有资源可用
    * <= 0 资源忙，需等待
    * 申请资源 **wait** 原子操作
    * 释放资源 **signal** 原子操作

```
var s int;
wait(s); // 申请资源
{
    while s <= 0 do no-op;
    s = s - 1;
}
signal(s); // 释放资源
{
    s = s + 1;
}
// 临界区代码
{
    wait(s);
    CS // do with critical resources
    signal(s);
}
```
* 记录型信号量机制
    * 定义一个 **记录型变量** ，用该变量的值来 **标记资源的使用情况**

```
type semaphore = record
    value: integer; // 资源数量 
    // value < 0 时表示资源数量
    // value < 0 时绝对值表示阻塞进程数量
    l: list of process; // 阻塞队列
end;

var s semaphore;

wait(s);
{
    s.value = s.value - 1;
    if s.value < 0 then block(s.l);
}
signal(s);
{
    s.value = s.value + 1;
    if s.value <= 0 then wakeup(s.l);
}
```
* AND 型信号量机制
    * 将进程在整个运行过程中所需要的资源一次性全部分配给进程，使用完一起释放

```
swait(s1, s2, ..., sn);
{
    if s1 >= 1 and ... sn >= 1 then
        for i = 1 to n do si = si - 1
        end for;
    else
        // 把进程插入si阻塞队列，并把程序计数器赋值为swait的起始地址
    end if
}
ssignal(s1, s2, ..., sn);
{
    for i = 1 to n do 
        si = si + 1;
        // 将阻塞在si队列中的进程唤醒，插入就绪队列
    end for;
}

```
---
未完待续

